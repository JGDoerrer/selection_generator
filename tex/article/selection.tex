\documentclass[10pt,journal,compsoc]{IEEEtran}

\usepackage{tikz}




% *** CITATION PACKAGES ***
%
\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
  \usepackage[nocompress]{cite}
\else
  % normal IEEE
  \usepackage{cite}
\fi

% *** MATH PACKAGES ***
%
\usepackage{amsmath}

\interdisplaylinepenalty=2500


\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}

\hyphenation{op-tical net-works semi-conduc-tor}

\makeatletter
\def\endthebibliography{%
  \def\@noitemerr{\@latex@warning{Empty `thebibliography' environment}}%
  \endlist
}
\makeatother

\begin{document}

\title{Finding Lower Bounds for the Number of Comparison in Selection Algorithms}

\author{Josua Dörrer, Konrad Gendle, Johanna Hofmann, Julius von Smercek, Andreas Steding% <-this % stops a space
  \IEEEcompsocitemizethanks{\IEEEcompsocthanksitem Institut für Formale Methoden der Informatik (FMI)\protect\\
    Universität Stuttgart
  }}

\markboth{Bachelor-Forschungsprojekt}%
{Submission}

\IEEEtitleabstractindextext{%
  \begin{abstract}
    This research project aims to find worst case optimal comparison algorithms for selecting the i-th smallest of n elements of a set for n up to 15 with computer search.
  \end{abstract}

  \begin{IEEEkeywords}
    Selection, Pessimistic lower Bound, Partial Order Sets, Computer Search
  \end{IEEEkeywords}}


\maketitle

\IEEEdisplaynontitleabstractindextext


\IEEEpeerreviewmaketitle

\IEEEraisesectionheading{\section{Motivation}\label{sec:motivation}}

\IEEEPARstart{T}{he} problem of selecting the $i$th smallest element in a list of $n$ elements is a well known problem in computer science. The problem can be solved by sorting the list and then selecting the $i$th element. However, this approach has a time complexity of $\mathcal{O}(n \log n)$. For some small values of i and n algorithms could be found that require fewer comparisons. For example, the fourth largest element in a list of 12 elements can be found with 12 comparisons in the worst case (improving the theoretical bound of $n \log n$ by factor 2). \cite[p. 212]{Knuth1973} Generally, by introducing elegant methods for comparing the elements of a list, upper bounds can be established. On the contrary, showing that a method uses the optimal amount of comparisons requires an extended set of tools. Gasarch et al. \cite{Gasarch1996} first introduced computer search to find optimal numbers of comparisons for small values of $n$ and $i$ as well as upper bounds for slightly larger values of $i$ and $n$.

On his website, Kenneth Oksanen \cite{Oksanen} published a computer search algorithm for this problem along with results that improve previously known lower bounds for n=13, n=14 and n=15. However, the results are not published in a scientific journal and lack explanation. \newline
%Der folgende Abschnitt sollte im Hinblick auf unsere Vorgehensweise beim Verfassen der Ausarbeitung angepasst werden. Indem wir uns evtl. im Vorfeld auf eine genaue Formulierung verständigen, platzieren wir den roten Faden für die restliche Ausarbeitung.
In this project we are interested in retracing the results of Oksanen by implementing his algorithm and exploring the benefit of Forward Search versus Backward Search. Furthermore, the potential of Bidirectional search, Alpha-Beta-Pruning and the exploitation of compatible Posets is assessed. \newline
\\
\textit{Extract from: cs.hut.fi/~cessu/selection/:}
\IEEEPARstart{T}{he} problem has been widely studied
in literature. Knuth gives a brief history of the problem and some known upper and lower bounds.
Optimal algorithms are known for any `n' when `i' is one or two, but for example for finding
the median ($i = n/2$), there is a significant performance gap from the best known algorithm
(approximately $2.97 n + o(n)$ comparisons) to the tightest known minimum $(2 n - o\left (n \right )$).

Many other special cases are also known, such as the ones given in the table below. Many of
these were previously found by Gasarch, Kelly and Pugh who introduced computer searching to
find the optimal selection algorithms. The additional results presented in the table above have
been found by my independent implementation, but it probably shares many characteristics with
Gasarch's.



\section{Fundamentals}
\subsection{Partial Order}
\subsection{Algorithms for Finding the 'i-th' of 'n'}

\section{Methods and Tools}
\subsection{Forward Search}
Forward Search starts with an empty Poset, i.e. one with entirely unknown ordering of its elements, and recursively determines solvability of a given Poset within some bound by exhaustively searching the results of all possible comparisons to be made unless it is already solved or we determine that it cannot be solved within the alloted number of comparisons by some heuristic.

Between the two possible outcomes of a comparison we assume the worse, but since an algorithm is free to choose which elements to compare we are looking for the most useful comparison, the one that yields result Posets cheapest to solve themselves, still in terms of worst case outcome. 
The algorithms output by the search program are built by saving the comparison that lead to this cheapest to solve result.

To limit memory cost and allow further pruning we traverse the search tree depth first, reducing the maximum number of comparisons alloted to child Posets to one less than the current best result found.
This premise is implemented by Minimax algorithms as shown in figure~\ref{fig:minimax_search}.

We can drastically speed up this exploration by caching previous results, even with a simple usage based ejection policy. Since the search always imposes an upper bound for the number of comparisons to allow this also includes yet unsolved Posets, for which we note the currently known minimum.

It is optimal because of an inductive argument over the number of relative orders deternined. An already solved Poset obviously takes no further comparisons to solve. Then given an unsolved Poset with all elements already too large or small excluded we must make at least one more comparison to make progress. 
Since all Posets resulting from these comparisons must have more elemets ordered than the current one has we can assume as per induction that we know their optimal cost.
Then we cannot solve the Poset in less than the cost of the cheapest of these comparisons, plus one for the comparison itself, hence the current Poset is also solved optimally.

It is also complete for a given upper bound, explainable through a similar inductive argument. If the Poset is solvable within that bound then at least one of its possible comparisons must have both outcomes be solvable within the bound lowered by one. Since the search only lowers the bound imposed on its recursive descendants beyond that once at least one has been solved, we are also guaranteed to find a solution for the original Poset if it exists within the bound.

\begin{figure}
  \begin{tikzpicture}[scale=0.8]
    \tiny
    \node (A1) at (0,0) {$\vdots$};
    \node (A2) at (2,0) {$\vdots$};
    \node (A3) at (3.5,0.4) {$\dots$};
    \node (A4) at (6,0) {$\vdots$};

    \node (B1) at (2,1) {MIN};

    \draw (B1) -- (A1) node[above,pos=0.6, xshift=-0.4cm] {$\{1,3\}$};
    \draw (B1) -- (A2) node[right, midway] {$\{1,4\}$};
    \draw (B1) -- (A4) node[right, pos=0.3, xshift=6mm] {$\{n \!- \! 1,n\}$};

    \node (C1) at (5,2) {MAX};
    \node (B2) at (7,1) {$\vdots$};

    \draw (C1) -- (B2) node[right, pos=0.3, xshift=4mm] {$(2,1)$};

    \draw (B1) -- (C1) node[left, pos=0.7, xshift=-4mm] {$(1,2)$};

    \node (D1) at (8,3) {MIN};
    \node (C2) at (8,2) {$\vdots$};
    \node (C3) at (8.7,2.3) {$\dots$};
    \node (C4) at (10,2) {$\vdots$};

    \draw (D1) -- (C1) node[left,pos=0.3,xshift=-3mm] {$\{1,2\}$};
    \draw (D1) -- (C2) node[left, midway, xshift=0.5mm] {$\{1,3 \! \}$};
    \draw (D1) -- (C4) node[right, pos=0.3,xshift=2mm] {$\{n \! - \! 1,n\}$};
    
  \end{tikzpicture}
  \caption{Minimax search algorithm} \label{fig:minimax_search}
\end{figure}

\subsection{Backward Search}

Backward search starts with a solved Poset, then repeatedly attempts to remove comparisons from its frontier Posets such that the same Poset with the opposite comparison result is also found within those already discovered.

Thus the number of iterations taken until a Poset is added to the frontier equals the number of worst case comparisons needed to solve it, which means that the search terminates once the empty Poset with the desired $n$ and $i$ is found.

The argument for the correctness is the number of comparisons we have found all Posets solvable within them for, equal to the number of iterations of the search.
If for a given Poset and a comparison within it we have already discovered both results then their cost must be less than the current number of iterations, so the Poset is solvable within that number and because this did not hold true in a previous iteration the cost must also be optimal.
And if a Poset is solvable within that number of comparisons it must have at least one comparison with a result among the Posets discovered in the previous iteration, as otherwise it would have to be solvable in less.

\subsection{Bidirectional Search}

\subsection{$\alpha$-$\beta$-pruning}

\subsection{Compatible Posets}

Let $P_{n,i}$ be a poset.
\begin{definition}
  A poset $R_{n,i}$ is compatible with $P_{n,i}$, if $R_{n,i}$ is solved and $P_{n,i} \subseteq R_{n,i}$.
  Let $$\mathcal{C}(P_{n,i}) = \{ R_{n,i} \text{ canonical poset } \mid R_{n,i} \text{ compatible with } P_{n,i} \}$$ be the set of all compatible posets of $P$.
\end{definition}

\begin{lemma}
  A poset $P_{n,i}$ is solved iff $|\mathcal{C}(P_{n,i})| = 1$.

  $\implies$: trivial

  $\impliedby$: trivial
\end{lemma}

\begin{lemma}
  Adding a comparison reduces the number of compatible posets by a factor $\leq 2$.

  Let $R_{n,i} = P_{n,i} + uv$.

  \begin{align*}
    \mathcal{C}(R_{n,i}) & = \mathcal{C}(P_{n,i}) \cap \{ \text{Posets with } uv \}   \\
    \mathcal{C}(P_{n,i}) & = \mathcal{C}(P_{n,i} + uv) \cup \mathcal{C}(P_{n,i} + vu) \\
  \end{align*}

  $$2 \cdot |\mathcal{C}(R_{n,i})| \leq |\mathcal{C}(P_{n,i})|$$
\end{lemma}

\begin{theorem}
  A poset $P_{n,i}$ is not solvable in less than $\log_2(|\mathcal{C}(P_{n,i})|)$ comparisons.


\end{theorem}

\section{Results}
\subsection{Search evaluation}
\subsubsection{Backward search}
\subsubsection{bidirectional search}
\subsubsection{forward search}

\subsection{Algorithmic improvements}
\subsubsection{Estimate solveable heuristic}
\subsubsection{Lower-Triangle}
\subsubsection{Multithreading}

\section{Conclusion}
We found a better solution hooray!
These are points we'd like to take into account for further research


\appendices
\section{Proof of the First Zonklar Equation}
Appendix one text goes here.
\section{}
Appendix two text goes here.


\ifCLASSOPTIONcompsoc
  \section*{Acknowledgments}
\else
  \section*{Acknowledgment}
\fi


The authors would like to thank...

\ifCLASSOPTIONcaptionsoff
  \newpage
\fi


\bibliographystyle{IEEEtran}
\bibliography{biblio.bib}
\end{document}