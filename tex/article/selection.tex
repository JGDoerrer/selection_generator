\documentclass[10pt,journal,compsoc]{IEEEtran}

\usepackage{tikz}




% *** CITATION PACKAGES ***
%
\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
  \usepackage[nocompress]{cite}
\else
  % normal IEEE
  \usepackage{cite}
\fi

% *** MATH PACKAGES ***
%
\usepackage{amsmath}

\interdisplaylinepenalty=2500


\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}

\hyphenation{op-tical net-works semi-conduc-tor}

\makeatletter
\def\endthebibliography{%
  \def\@noitemerr{\@latex@warning{Empty `thebibliography' environment}}%
  \endlist
}
\makeatother

\begin{document}

\title{Finding Lower Bounds for the Number of Comparison in Selection Algorithms}

\author{Josua Dörrer, Konrad Gendle, Johanna Hofmann, Julius von Smercek, Andreas Steding% <-this % stops a space
  \IEEEcompsocitemizethanks{\IEEEcompsocthanksitem Institut für Formale Methoden der Informatik (FMI)\protect\\
    Universität Stuttgart
  }}

\markboth{Bachelor-Forschungsprojekt}%
{Submission}

\IEEEtitleabstractindextext{%
  \begin{abstract}
    This summary aims to briefly describe the core points of the.
  \end{abstract}

  \begin{IEEEkeywords}
    Add some keywords of your summary/the article. \cite{DBLP:journals/corr/abs-2001-02478,}
  \end{IEEEkeywords}}


\maketitle

\IEEEdisplaynontitleabstractindextext


\IEEEpeerreviewmaketitle

\IEEEraisesectionheading{\section{Motivation}\label{sec:motivation}}

\IEEEPARstart{T}{he} problem of selecting the $i$th largest element in a list of $n$ elements is a well known problem in computer science. The problem can be solved by sorting the list and then selecting the $i$th element. However, this approach has a time complexity of $\mathcal{O}(n \log n)$. For some small values of i and n algorithms could be found that require fewer comparisons. For example, the fourth largest element in a list of 12 elements can be found with 12 comparisons in the worst case (improving the theoretical bound of $n \log n$ by factor 2). \cite[p. 212]{Knuth1973} Generally, by introducing elegant methods for comparing the elements of a list, upper bounds can be established. On the contrary, showing that a method uses the optimal amount of comparisons requires an extended set of tools. Gasarch et al. \cite{Gasarch1996} first introduced computer search to find optimal numbers of comparisons for small values of $n$ and $i$ as well as upper bounds for slightly larger values of $i$ and $n$.

On his website, Kenneth Oksanen \cite{Oksanen} published a computer search algorithm for this problem along with results that improve previously known lower bounds for n=13, n=14 and n=15. However, the results are not published in a scientific journal and lack explanation. \newline
%Der folgende Abschnitt sollte im Hinblick auf unsere Vorgehensweise beim Verfassen der Ausarbeitung angepasst werden. Indem wir uns evtl. im Vorfeld auf eine genaue Formulierung verständigen, platzieren wir den roten Faden für die restliche Ausarbeitung.
In this project we are interested in retracing the results of Oksanen by implementing his algorithm and exploring the benefit of Forward Search versus Backward Search. Furthermore, the potential of Bidirectional search, Alpha-Beta-Pruning and the exploitation of compatible Posets is assessed. \newline
\\
\textit{Extract from: cs.hut.fi/~cessu/selection/:}
\IEEEPARstart{T}{he} problem has been widely studied
in literature. Knuth gives a brief history of the problem and some known upper and lower bounds.
Optimal algorithms are known for any `n' when `i' is one or two, but for example for finding
the median ($i = n/2$), there is a significant performance gap from the best known algorithm
(approximately $2.97 n + o(n)$ comparisons) to the tightest known minimum $(2 n - o\left (n \right )$).

Many other special cases are also known, such as the ones given in the table below. Many of
these were previously found by Gasarch, Kelly and Pugh who introduced computer searching to
find the optimal selection algorithms. The additional results presented in the table above have
been found by my independent implementation, but it probably shares many characteristics with
Gasarch's.



\section{Fundamentals}
\subsection{Partial Order}
\subsection{Algorithms for Finding the 'i-th' of 'n'}

\section{Methods and Tools}
\subsection{Forward Search}
The notion of forward search encompasses the top-down traversal of a search tree whose nodes are partial orders.
The root of the tree is the empty poset, and the leaves are the solvable posets. 
The search tree is traversed in a depth-first manner, and the search is terminated as soon as a solved poset is found.
The goal is to determine the minimum number of comparisons required to solve the poset. 
This number has to hold even for the worst case outcome of the comparisons. 
However, the comparisons, e.g. the choice of the elements to be compared is free. 
The optimal choice is to be determined during the search.
This premise is implemented by Minimax algorithms as shown in figure~\ref{fig:minimax_search}.

\begin{figure}
  \begin{tikzpicture}[scale=0.8]
    \tiny
    \node (A1) at (0,0) {$\vdots$};
    \node (A2) at (2,0) {$\vdots$};
    \node (A3) at (3.5,0.4) {$\dots$};
    \node (A4) at (6,0) {$\vdots$};

    \node (B1) at (2,1) {MIN};

    \draw (B1) -- (A1) node[above,pos=0.6, xshift=-0.4cm] {$\{1,3\}$};
    \draw (B1) -- (A2) node[right, midway] {$\{1,4\}$};
    \draw (B1) -- (A4) node[right, pos=0.3, xshift=6mm] {$\{n \!- \! 1,n\}$};

    \node (C1) at (5,2) {MAX};
    \node (B2) at (7,1) {$\vdots$};

    \draw (C1) -- (B2) node[right, pos=0.3, xshift=4mm] {$(2,1)$};

    \draw (B1) -- (C1) node[left, pos=0.7, xshift=-4mm] {$(1,2)$};

    \node (D1) at (8,3) {MIN};
    \node (C2) at (8,2) {$\vdots$};
    \node (C3) at (8.7,2.3) {$\dots$};
    \node (C4) at (10,2) {$\vdots$};

    \draw (D1) -- (C1) node[left,pos=0.3,xshift=-3mm] {$\{1,2\}$};
    \draw (D1) -- (C2) node[left, midway, xshift=0.5mm] {$\{1,3 \! \}$};
    \draw (D1) -- (C4) node[right, pos=0.3,xshift=2mm] {$\{n \! - \! 1,n\}$};
    
  \end{tikzpicture}
  \caption{Minimax search algorithm} \label{fig:minimax_search}
\end{figure}

\subsection{Backward search}

\subsection{Bidirectional Search}

\subsection{$\alpha$-$\beta$-pruning}

\subsection{Compatible Posets}

Let $P_{n,i}$ be a poset.
\begin{definition}
  A poset $R_{n,i}$ is compatible with $P_{n,i}$, if $R_{n,i}$ is solved and $P_{n,i} \subseteq R_{n,i}$.
  Let $$\mathcal{C}(P_{n,i}) = \{ R_{n,i} \text{ canonical poset } \mid R_{n,i} \text{ compatible with } P_{n,i} \}$$ be the set of all compatible posets of $P$.
\end{definition}

\begin{lemma}
  A poset $P_{n,i}$ is solved iff $|\mathcal{C}(P_{n,i})| = 1$.

  $\implies$: trivial

  $\impliedby$: trivial
\end{lemma}

\begin{lemma}
  Adding a comparison reduces the number of compatible posets by a factor $\leq 2$.

  Let $R_{n,i} = P_{n,i} + uv$.

  \begin{align*}
    \mathcal{C}(R_{n,i}) & = \mathcal{C}(P_{n,i}) \cap \{ \text{Posets with } uv \}   \\
    \mathcal{C}(P_{n,i}) & = \mathcal{C}(P_{n,i} + uv) \cup \mathcal{C}(P_{n,i} + vu) \\
  \end{align*}

  $$2 \cdot |\mathcal{C}(R_{n,i})| \leq |\mathcal{C}(P_{n,i})|$$
\end{lemma}

\begin{theorem}
  A poset $P_{n,i}$ is not solvable in less than $\log_2(|\mathcal{C}(P_{n,i})|)$ comparisons.


\end{theorem}

\section{Results}
\subsection{Search evaluation}
\subsubsection{Backward search}
\subsubsection{bidirectional search}
\subsubsection{forward search}

\subsection{Algorithmic improvements}
\subsubsection{Estimate solveable heuristic}
\subsubsection{Lower-Triangle}
\subsubsection{Multithreading}

\section{Conclusion}
We found a better solution hooray!
These are points we'd like to take into account for further research


\appendices
\section{Proof of the First Zonklar Equation}
Appendix one text goes here.
\section{}
Appendix two text goes here.


\ifCLASSOPTIONcompsoc
  \section*{Acknowledgments}
\else
  \section*{Acknowledgment}
\fi


The authors would like to thank...

\ifCLASSOPTIONcaptionsoff
  \newpage
\fi


\bibliographystyle{IEEEtran}
\bibliography{biblio.bib}
\end{document}