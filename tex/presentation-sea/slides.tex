\only<beamer>{\titleframe}

\author{SEA 2025 \hspace{1cm} Johanna Hofmann}
\section{Introduction}

% TODO: letzte Folie, full url
%  https://medium.com/@teamtechsis/introduction-to-sorting-algorithms-1623b9cdd4f1
% https://www.geeksforgeeks.org/dsa/quick-sort-algorithm/

\begin{frame}{The Selection Problem}
  \framesubtitle{Finding the $i$-th Smallest Element}
  \textbf{Selection($n,i$):} Find the $i$-th smallest value in a collection of $n$ distinct values.
  \vfill
  \centering
  Common approaches are based on sorting or partitioning:
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
      \centering
      \textbf{Sorting}\\
      \includegraphics[width=0.8\textwidth, trim={0 0 0 3.5cm}, clip]{figures/Insertion_sort.jpg}\\
      \tiny{Source: medium.com/@teamtechsis}
    \end{column}
    \begin{column}{0.45\textwidth}
      \centering
      \textbf{Pivoting}\\
      \includegraphics[width=0.8\textwidth]{figures/Pivot.jpg}\\
      \tiny{Source: geeksforgeeks.org}
    \end{column}
  \end{columns}

  \note{
    \begin{itemize}
      \item However, we focused on the exact number of comparisons required to solve the problem for relatively small numbers.
      \item Namely determining the number of comparisons needed to find the $i$-th smallest value in a collection of $n$ values.
      \item All baseline algorithms are based on the principle of either sorting or pivoting. By counting the comparisons during runtime one obtains the $i$-the smallest element end the number of comparisons at the same time.
      \item However, with Computer search one can obtain the number of comparisons needed and a general algorithm for retrieving the $i$th-smallest element.
      \item This brings us to the previous work on this topic. We concerend ourselves with the complexity of the selection algorithm. Of course one can solely regard the asymptotic behavior of the problem and get an accurate idea of the time complexity for large n.
    \end{itemize}
  }
\end{frame}

% TODO: diese Folie hat viel zu viel Text
\begin{frame}{Complexity of the Selection Problem}
  \framesubtitle{Known Asymptotic Bounds}
  \begin{itemize}
    \item<+-> Let $V_i^n$ be the worst-case number of comparisons for an optimal algorithm.
    \item<+-> Selecting the minimum is simple: $V_1(n) = n-1$.
    \item<+-> For the general case, the Median of Medians algorithm provides a linear time complexity of $\mathcal{O}(n)$.
    \item<+-> The best-known upper bound for selecting the median is $\approx 2.95n$ comparisons.
    \item<+-> The best-known lower bound for the median is $\approx 2.41n$ comparisons.
    \item<+-> \textbf{Our Question:} What are the \textit{exact} values of $V_i^n$ for small $n$ and arbitrary $i$, and how do they compare to these general bounds?
  \end{itemize}
\end{frame}

% TODO: figure to small
\begin{frame}{Complexity of the Selection Problem}
  \begin{figure}
    \includegraphics[height=0.65\textheight]{figures/bounds_diagram.png}
    \caption{Complexity bounds}
  \end{figure}
\end{frame}

\begin{frame}{Previous Work on Exact Bounds}
  \begin{tabular}{|p{6cm}|p{6cm}|}
    \hline
    \multicolumn{1}{|c|}{Gasarch, Kelly and Puth (1996)}                                               & \multicolumn{1}{c|}{Oksanen (2002)} \\
    \cline{1-2}
    \raggedright \begin{itemize}
                   \item [...]were the first to apply computer search to find lower bounds for the selection problem.
                         %\item [...]nutzten für größere $n,i$ sog. \textit{pair-forming algorithms}
                 \end{itemize} &
    \begin{itemize}
      \item[...] published a computer search algorithm that surpassed the lower bounds of Gasarch et al.
    \end{itemize}                                        \\
    \cline{1-2}
  \end{tabular}

  \note{This is a note}
\end{frame}

% \section{Grundlagen}

% \subsection{Partial Order Sets}

% \sectionframe{\insertsection}

% \begin{frame}{Zentrale Datenstruktur: Poset}
%   \textbf{Definition:}
%   \vspace{1mm}
%   \begin{itemize}
%     \item Sei $\Omega$ eine Menge mit paarweise verschiedenen Elementen mit $\vert \Omega \vert = n$.
%     \item $(n,i,R)$ bezeichnet eine Instanz des \textit{Selection}-Problems.
%     \item $R \subseteq \Omega^2$ mit $(a,b) \in R \Leftrightarrow a \leq b$.
%   \end{itemize}
%   \vspace{2mm}
% \end{frame}

% \begin{frame}{Zentrale Datenstruktur: Poset}
%   \textbf{Dualität:} \\
%   \vspace{1mm}
%   Das Duale eines Posets $P = (n, i, R)$ ist das Poset $P^{-1} = \left(n, n-1-i, R'\right)$ mit $R' = \{ (u,v) \; \vert \; (v,u) \in R\}$.

%   \pause
%   \vspace{2mm}
%   \textbf{Reduktion:} \\
%   \vspace{1mm}
%   Ein Poset heißt \textit{reduziert}, wenn es zu jedem Element höchstens $i$ viele kleinere Elemente gibt und höchstens $n-1-i$ viele größere Elemente.
% \end{frame}

% \begin{frame}{Zentrale Datenstruktur: Poset}
%   \textbf{Kanonische Form:} \\
%   \vspace{1mm}
%   Ein Poset heißt \textit{kanonifiziert}, wenn alle Elemente des Posets kanonisch angeordnet sind. Das heißt, dass alle möglichen Permutationen der Elemente auf das Poset abbilden.

%   \pause
%   \vspace{2mm}
%   \textbf{Normalform:} \\
%   \vspace{1mm}
%   Ein reduziertes und kanonifiziertes Poset heißt \textit{normalisiert}.

%   \pause
%   \vspace{2mm}
%   \textbf{Optimale Kosten:} \\
%   \vspace{1mm}
%   \textit{Kosten eines Posets} $V(P)$ mit $P=(n,i,R)$ sind die optimale Anzahl an weiteren Vergleichen, die benötigt werden, um das $i$ kleinste Element zu bestimmen.
% \end{frame}

% \begin{frame}{Ein Lemma}
%   \textbf{Lemma 1:} Für ein Poset $P=(n,i,R)$ gilt $V(P) = V(P^{-1})$.
%   \vspace{1mm}

%   \textit{Beweis: Die Berechnung von $V(P)$ ergibt gleichzeitig einen Algorithmus, der in einen Entscheidungsbaum übersetzt werden kann. Vertausche alle Kinder, und derselbe Algorithmus führt auf die Lösung von $P^{-1}$.}

% \end{frame}

% \begin{frame}{Ein Beispiel mit Poset-Reduktion}
%   \begin{figure}
%     \input{figures/tikz_example}
%   \end{figure}

% \end{frame}

% \subsection{Kompatible Lösungen}
% \begin{frame}{\insertsubsection}
%   \centering
%   \begin{tikzpicture}

%     \node[draw, circle] (l0) at (0, 0) {};
%     \node[draw, circle] (l1) at (1, 0) {};
%     \node[draw, circle] (l2) at (2, 0) {};
%     \node[draw, circle] (l3) at (3, 0) {};

%     \node[draw, circle] (I) at (1.5, 2) {$i$};

%     \path[draw] (l0) to (I);
%     \path[draw] (l1) to (I);
%     \path[draw] (l2) to (I);
%     \path[draw] (l3) to (I);

%     \node[draw, circle] (u0) at (0.5, 4) {};
%     \node[draw, circle] (u1) at (1.5, 4) {};
%     \node[draw, circle] (u2) at (2.5, 4) {};

%     \path[draw] (u0) to (I);
%     \path[draw] (u1) to (I);
%     \path[draw] (u2) to (I);

%   \end{tikzpicture}

% \end{frame}

% \begin{frame}{\insertsubsection}
%   \centering
%   \begin{tikzpicture}

%     \node[draw, circle] (fl0) at (0, 0) {};
%     \node[draw, circle] (fl1) at (1, 0) {};
%     \node[draw, circle] (fl2) at (2, 0) {};
%     \node[draw, circle] (fl3) at (3, 0) {};

%     \node[draw, circle] (fI) at (1.5, 2) {$i$};

%     \path[draw] (fl0) to (fI);
%     \path[draw] (fl1) to (fI);
%     \path[draw] (fl2) to (fI);
%     \path[draw] (fl3) to (fI);

%     \node[draw, circle] (fu0) at (0.5, 4) {};
%     \node[draw, circle] (fu1) at (1.5, 4) {};
%     \node[draw, circle] (fu2) at (2.5, 4) {};

%     \path[draw] (fu0) to (fI);
%     \path[draw] (fu1) to (fI);
%     \path[draw] (fu2) to (fI);

%     \path[draw=red] (fu0) to (fl1);

%     %second

%     \node[draw, circle] (sl0) at (0 + 5, 0) {};
%     \node[draw, circle] (sl1) at (1 + 5, 0) {};
%     \node[draw, circle] (sl2) at (2 + 5, 0) {};
%     \node[draw, circle] (sl3) at (3 + 5, 0) {};

%     \node[draw, circle] (sI) at (1.5 + 5, 2) {$i$};

%     \path[draw] (sl0) to (sI);
%     \path[draw] (sl1) to (sI);
%     \path[draw] (sl2) to (sI);
%     \path[draw] (sl3) to (sI);

%     \node[draw, circle] (su0) at (0.5 + 5, 4) {};
%     \node[draw, circle] (su1) at (1.5 + 5, 4) {};
%     \node[draw, circle] (su2) at (2.5 + 5, 4) {};

%     \path[draw] (su0) to (sI);
%     \path[draw] (su1) to (sI);
%     \path[draw] (su2) to (sI);

%     \path[draw=red] (su0) to (su1);

%   \end{tikzpicture}

% \end{frame}

% \subsection{Kompatible Lösungen}
% \begin{frame}{\insertsubsection}
%   \centering
%   \includegraphics[scale=.5]{../article/figures/compatible_cost_relation.png}

% \end{frame}




\section{Forward Search}
\sectionframe{\insertsection}

\begin{frame}{\insertsection: A Minimax Approach}
  \centering
  \begin{tikzpicture}
    [
      level 1/.style = {sibling distance = 4cm},
      level 2/.style = {sibling distance = 2.5cm},
    ]

    \node[anchor=east] at (-7,0) {Min};
    \node[anchor=east] at (-7,-1.5) {Max};
    \node[anchor=east] at (-7,-3) {Min};
    \node[anchor=east] at (-7,-4.5) {Max};

    \node[] (root) {$(n,i,\emptyset)$}
    child {
        node[] {$\{a,b\}$}
        child {
            node[] {$(n,i,\{(a,b)\})$}
            child[sibling distance = 1cm] {
                node[] {$\{c,d\}$}
                child[sibling distance = 1cm] { node[] {$\cdots$}}
                child[sibling distance = 1cm] { node[] {$\cdots$}}
              }
            child[sibling distance = 1cm] { node[] {$\cdots$}}
          }
        child {
            node[] {$(n,i,\{(b,a)\})$}
            child[sibling distance = 1cm] {
                node[] {$\{c,d\}$}
                child[sibling distance = 1cm] { node[] {$\cdots$}}
                child[sibling distance = 1cm] { node[] {$\cdots$}}
              }
            child[sibling distance = 1cm] { node[] {$\cdots$}}
          }
      }
    child {
        node {$\{a,c\}$}
        child[sibling distance = 1cm] { node[] {$\cdots$}}
        child[sibling distance = 1cm] { node[] {$\cdots$}}
      }
    child {
        node[] {$\cdots$}
      }
    ;

  \end{tikzpicture}
  \note{
    \begin{itemize}
      \item The forward search starts with the empty poset and recursively determines the cost of selecting the $i$-th smallest element of a poset $P$.
      \item This is implemented using a minimax algorithm.
      \item Between all pairs of elements the pair is compared that yields the smallest number of comparisons.
      \item Between the two possible outcomes of a comparison, the worst case is assumed.
      \item To save memory and enable pruning, the search tree is traversed using a depth-first search.
      \item The maximum number of comparisons assigned to child problems is limited to one less than the current best result.
      \item The search program builds algorithms by recording, for each problem, the comparison that led to the cheapest result.
    \end{itemize} }
\end{frame}

\begin{frame}{Optimizations}
  \begin{tikzpicture}
    [
      level 1/.style = {sibling distance = 4cm},
      level 2/.style = {sibling distance = 2.5cm},
    ]

    \node[anchor=east] at (-7,2) {Min};
    \node[anchor=east] at (-7,0.5) {Max};
    \node[anchor=east] at (-7,-1) {Min};
    \node[anchor=east] at (-7,-2.5) {Max};

    \node[] (root) at (0,2) {$(n,i,\emptyset)$}
    child {
        node[] {$\{a,b\}$}
        child {
            node[] {$(n,i,\{(a,b)\})$}
            child[sibling distance = 1cm] {
                node[] {$\{c,d\}$}
                child[sibling distance = 1cm] { node[] {$\cdots$}}
                child[sibling distance = 1cm] { node[] {$\cdots$}}
              }
            child[sibling distance = 1cm] { node[] {$\cdots$}}
          }
        child {
            node[] {$(n,i,\{(b,a)\})$}
            child[sibling distance = 1cm] {
                node[] {$\{c,d\}$}
                child[sibling distance = 1cm] { node[] {$\cdots$}}
                child[sibling distance = 1cm] { node[] {$\cdots$}}
              }
            child[sibling distance = 1cm] { node[] {$\cdots$}}
          }
      }
    child {
        node {$\{a,c\}$}
        child[sibling distance = 1cm] { node[] {$\cdots$}}
        child[sibling distance = 1cm] { node[] {$\cdots$}}
      }
    child {
        node[] {$\cdots$}
      }
    ;

    \node[anchor=north east] at (8,-1.0) {
      \parbox{7cm}{
        \begin{itemize}
          \item \textbf{Iterative deepening}
          \item \textbf{Cache}
        \end{itemize}
      }
    };
    \node[anchor=north east] at (6.8,-2.1) {
      \parbox{5cm}{
        \begin{tabular}{|l|c|}
          \toprule
          Poset             & Min \#comp \\
          \midrule
          $(n,i,\{(a,b)\})$ & 1          \\
          $(n,i,\{(b,a)\})$ & 1          \\
          \bottomrule
        \end{tabular}
      }
    };
  \end{tikzpicture}

  \note{\begin{itemize}
      \item We apply depth-first search with iterative deepening.
      \item This saves memory and previous results are cached.
      \item We store an approximated canonical representation of the problem and its dual in the cache along with the number of comparisons applied so far.
      \item Each entry indicates that the poset is not solvable with just this amount of comparisons.
      \item Besides for simple reusing purposes, the information in the chach can be used for pruning, by cutting off branches that contradict the minimum value in the cache.
    \end{itemize}
  }
\end{frame}

\begin{frame}{Pruning techniques}
  \begin{itemize}
    \item Compatible Solutions
    \item Free Comparison
  \end{itemize}

  \note{\begin{itemize}
      \item We applied to furhter pruning techniques, which are based on compatible solutions and a free comparison
    \end{itemize}
  }
\end{frame}

\begin{frame}{Pruning technique: Compatible solutions}

  The solved problem $(S,i)$ is a \textbf{compatible solution} of the problem $(R,i)$, if
  \begin{align*}
    a \leq_S b \Rightarrow b \not \leq a
  \end{align*}
  \vspace{1mm}

  Denote the \textbf{number of compatible solutions} with $\vert \mathcal{C}(P,i) \vert $\\
  \vspace{5mm}
  \hspace{-3mm}
  \begin{tabular}{l p{8cm}}
    \textbf{Lemma: } & Selecting the i-th smallest element of a poset P requires at least $\lceil log (|C(P, i)|) \rceil $ comparisons
  \end{tabular}
\end{frame}

\begin{frame}{Pruning technique: Compatible solutions}
  \only<1>{
    \begin{tikzpicture}
      [
        level 1/.style = {sibling distance = 4cm},
        level 2/.style = {sibling distance = 2.5cm},
      ]

      \node[anchor=east] at (-7,0) {Min};
      \node[anchor=east] at (-7,-1.5) {Max};
      \node[anchor=east] at (-7,-3) {Min};
      \node[anchor=east] at (-7,-4.5) {Max};

      \node[] (root) {$(n,i,\emptyset)$}
      child {
          node[] {$\{a,b\}$}
          child {
              node[] {$(n,i,\{(a,b)\})$}
              child[sibling distance = 1cm] {
                  node[] {$\{c,d\}$}
                  child[sibling distance = 1cm] { node[] {$\cdots$}}
                  child[sibling distance = 1cm] { node[] {$\cdots$}}
                }
              child[sibling distance = 1cm] { node[] {$\cdots$}}
            }
          child {
              node[] {$(n,i,\{(b,a)\})$}
              child[sibling distance = 1cm] {
                  node[] {\color{black}$\{c,d\}$}
                  child[sibling distance = 1cm, edge from parent/.style={draw,dashed}] { node[] {\color{red}42}}
                  child[sibling distance = 1cm] { node[] {$\cdots$}}
                }
              child[sibling distance = 1cm] { node[] {$\cdots$}}
            }
        }
      child {
          node {$\cdots$}
        }
      child {
          node[] {$\cdots$}
        }
      ;

    \end{tikzpicture}
  }
  \only<2>{
    \begin{tikzpicture}
      [
        level 1/.style = {sibling distance = 4cm},
        level 2/.style = {sibling distance = 2.5cm},
      ]

      \node[anchor=east] at (-7,0) {Min};
      \node[anchor=east] at (-7,-1.5) {Max};
      \node[anchor=east] at (-7,-3) {Min};
      \node[anchor=east] at (-7,-4.5) {Max};

      \node[] (root) {$(n,i,\emptyset)$}
      child {
          node[] {$\{a,b\}$}
          child {
              node[] {$(n,i,\{(a,b)\})$}
              child[sibling distance = 1cm] {
                  node[] {$\{c,d\}$}
                  child[sibling distance = 1cm] { node[] {$\cdots$}}
                  child[sibling distance = 1cm] { node[] {$\cdots$}}
                }
              child[sibling distance = 1cm] { node[] {$\cdots$}}
            }
          child {
              node[] {$(n,i,\{(b,a)\})$}
              child[sibling distance = 1cm,red] {
                  node[] {\color{black}$\{c,d\}$}
                  child[sibling distance = 1cm,red, edge from parent/.style={draw,dashed}] { node[] {\color{red}42}}
                  child[sibling distance = 1cm,black] { node[] {$\cdots$}}
                }
              child[sibling distance = 1cm] { node[] {$\cdots$}}
            }
        }
      child {
          node {$\cdots$}
        }
      child {
          node[] {$\cdots$}
        }
      ;

      \node [draw=none] at (-1, -3) {\color{red} $(\_, 42)$};
    \end{tikzpicture}
  }
  \only<3>{
    \begin{tikzpicture}
      [
        level 1/.style = {sibling distance = 4cm},
        level 2/.style = {sibling distance = 2.5cm},
      ]

      \node[anchor=east] at (-7,0) {Min};
      \node[anchor=east] at (-7,-1.5) {Max};
      \node[anchor=east] at (-7,-3) {Min};
      \node[anchor=east] at (-7,-4.5) {Max};

      \node[] (root) {$(n,i,\emptyset)$}
      child {
          node[] {$\{a,b\}$}
          child {
              node[] {$(n,i,\{(a,b)\})$}
              child[sibling distance = 1cm] {
                  node[] {$\{c,d\}$}
                  child[sibling distance = 1cm] { node[] {$\cdots$}}
                  child[sibling distance = 1cm] { node[] {$\cdots$}}
                }
              child[sibling distance = 1cm] { node[] {$\cdots$}}
            }
          child {
              node[] {$(n,i,\{(b,a)\})$}
              child[sibling distance = 1cm,red] {
                  node[] {\color{black}$\{c,d\}$}
                  child[sibling distance = 1cm,red,, edge from parent/.style={draw,dashed}] { node[] {\color{red}42}}
                  child[sibling distance = 1cm,black] { node[] {$\cdots$}}
                }
              child[sibling distance = 1cm] { node[] {$\cdots$}}
            }
        }
      child {
          node {$\cdots$}
        }
      child {
          node[] {$\cdots$}
        }
      ;

      \draw[red] (-3.7,-2) -- (-3,-2.5);
      \draw[red] (-3.7,-2.5) -- (-3,-2);

      \node [draw=none] at (-1, -3) {\color{red} $(\_, 42)$};
      \node [draw=none] at (-1, -2.25) {\color{red} If $42 < \lceil \log (\vert \mathcal{C}(P,i)\vert ) \rceil$};


    \end{tikzpicture}
  }

  \note{
    \begin{itemize}
      \item For example when one child turns out to be solvable with 42 comparisons, the value is propagated upwards. And e.g. this is a min node so upon completion the solution is at most 42. But when log of number of compatible solutions is larger than 42 this branch can be pruned.
    \end{itemize}
  }
\end{frame}

\subsection{Heuristiken}

\begin{frame}{\insertsubsection}

  \begin{itemize}
    \item<+-> Sortieren der Ebenen
    \item<+-> Kompatible Lösungen
      \begin{itemize}
        \item Anzahl Vergleiche $\geq \log_2$(Anzahl Kompatible Lösungen)
      \end{itemize}
    \item<+-> Geschenkter Vergleich
      \begin{figure}
        \centering
        \begin{tikzpicture}
          \node[draw,circle] (1) {};
          \node[draw,circle,below right of=1] (2) {};
          \node[draw,circle,below left of=1] (3) {};

          \node[draw,circle,above of=1] (4) {};
          \node[draw,circle,above right of=4] (5) {};
          \node[draw,circle,above left of=4] (6) {};

          \path[dashed] (1) edge (4);

          \path[-]
          (1) edge (2)
          (1) edge (3)
          (4) edge (5)
          (4) edge (6);
        \end{tikzpicture}
      \end{figure}
  \end{itemize}

\end{frame}

\author{SEA 2025 \hspace{1cm} Julius von Smercek}

\section{Backward Search}
\sectionframe{\insertsection}

\begin{frame}{\insertsection}
  Start with a solved poset and search the empty poset
  \vfill
  \begin{itemize}
    \item<+-> \textbf{Goal:} Given an upper bound $k$, find all posets solvable in at most $k$ comparisons.
    \item<+-> \textbf{Initialization:} Start with the set of all posets that are already ``solved'' (i.e., the $i$-th element is uniquely identified). Their cost is 0.
    \item<+-> \textbf{Iteration (Level $k \to k+1$):} To find all posets solvable in $k+1$ steps, find all \textit{predecessors} of posets solvable in $\leq k$ steps.
    \item<+-> \textbf{Termination:} The search stops when the initial empty poset $(n, i, \emptyset)$ is generated. Its level is the value $V_i^n$.
    \item<+-> \textbf{Canonization:} A unique normal form (with `nauty`) is expensive, but required. We use fast invariants to pre-filter, such that `nauty` is needed for only $< 0.1\%$ of posets.
  \end{itemize}
\end{frame}

\begin{frame}{Predecessor Computation}
  \begin{definition}[Predecessor]
    Suppose the set of all posets solvable in $k$ comparisons is known.
    A normalized poset $Q$ is a \textbf{predecessor} iff there exists a comparison between two elements $u,v$ such that
    \begin{enumerate}
      \item<+-> Adding the relation $(u,v)$ to $Q$ yields a known poset solvable in exact $k$ steps
      \item<+-> Adding the relation $(v,u)$ to $Q$ yields a known poset solvable in at maximum $k$ steps
      \item<+-> $Q$ itself was not found at a lower level
    \end{enumerate}
  \end{definition}
  \vfill
  This process essentially ``removes'' a comparison to go one step backward.
\end{frame}

\begin{frame}{Example}
  \vspace{-0.75cm}
  \begin{figure}[!b]
    \centering
    \scalebox{0.8}{\input{figures/tikz_backward_example.tex}}
    \caption{Search tree for $n=4,i=2$}
    \label{fig:backward-searchtree-bound4}
  \end{figure}

  \note{
    \begin{itemize}
      \item Level k contains all posets that can be solved in k comparisons and can be formed from the previous level(s)
      \item solid arrows: point to a poset in level k - 1 that results from removing a comparison
      \item dashed arrows: point to the poset that results when the inverse comparison is added (all levels less than k)
      \item Backward search starts at the bottom at k = 0, the only ``solved'' poset
      \item compute level k + 1 as follows:
            \begin{itemize}
              \item first, try to remove a comparison
              \item add an element with comparisons such that solvability is not affected & then remove a comparison
            \end{itemize}
    \end{itemize}
  }
\end{frame}

\begin{frame}{Removing Comparisons}
  \begin{figure}[!b]
    \centering
    \scalebox{1.5}{\input{figures/tikz_problematic_case.tex}}
    \caption{TODO}
    \label{fig:backward-problematic-case}
  \end{figure}

  \note{
  }
\end{frame}


\begin{frame}{Multithreading}
  % 1  core : 7h 2m 59s
  % 32 cores:   20m 11s
  \vspace{-1cm}

  \begin{figure}
    \centering
    \resizebox{0.8\textheight}{!}{%
      \begin{tikzpicture}
        \begin{axis}[
            ymin=0,
            ymax=1,
            axis x line=bottom,
            enlarge x limits=0.1,
            x axis line style={-},
            ylabel={Efficiency},
            xlabel={Number of Cores},
            ybar, % This makes the plot a bar chart
            bar width=0.2cm, % Adjust bar width
            % nodes near coords, % Display values on top of bars
            xtick=data, % Set x-ticks to data points
            symbolic x coords={1, 2, 4, 8, 16, 32}, % Specify the x-tick labels
          ]
          \addplot[
            ybar,
            fill=blue
          ] coordinates {
              (1, 1.000)
              (2, 0.892)
              (4, 0.877)
              (8, 0.851)
              (16, 0.803)
              (32, 0.655)
            };
        \end{axis}
      \end{tikzpicture}%
    }
    \caption{Efficiency of Parallelization for $n = 13, i = 6$}
  \end{figure}

  $\text{Efficiency} = (\text{single-core time}) \div (\text{number of cores} \cdot \text{multi-core time})$ \\
\end{frame}

\begin{frame}{Poset Distribution}
  \begin{figure}[!b]
    \centering
    \resizebox{0.9\textheight}{!}{%
      \input{figures/tikz_posets_per_level.tex}
    }
    \caption{Number of posets for $n = 14$ depending on the number of comparisons}
  \end{figure}
\end{frame}


\section{Results}
\sectionframe{\insertsection}

\begin{frame}{Exact Bounds} %ready
  \vspace{-1cm}
  \begin{table}[!t]
    \label{tab:results}
    \centering
    \small
    \begin{tabular}{c|cccccccc}
      $n$ & \multicolumn{8}{c}{$i$}                                                                                                      \\
          & 1                       & 2  & 3           & 4           & 5           & 6           & 7                 & 8                 \\ \hline
      1   & 0                                                                                                                            \\
      2   & 1                                                                                                                            \\
      3   & 2                       & 3                                                                                                  \\
      4   & 3                       & 4                                                                                                  \\
      5   & 4                       & 6  & 6                                                                                             \\
      6   & 5                       & 7  & 8                                                                                             \\
      7   & 6                       & 8  & 10          & 10                                                                              \\
      8   & 7                       & 9  & 11          & 12                                                                              \\
      9   & 8                       & 11 & 12          & 14          & 14                                                                \\
      10  & 9                       & 12 & 14          & 15          & 16                                                                \\
      11  & 10                      & 13 & 15          & 17          & 18          & 18                                                  \\
      12  & 11                      & 14 & 17          & 18          & 19          & 20                                                  \\
      13  & 12                      & 15 & 18          & 20          & 21          & 22          & 23                                    \\
      14  & 13                      & 16 & 19          & 21          & 23          & 24          & \textbf{25}                           \\
      15  & 14                      & 17 & 20          & 23          & \textbf{24} & \textbf{26} & \textbf{26}       & \textbf{27}       \\
      16  & 15                      & 18 & \textbf{21} & \textbf{24} & \textbf{26} & \textbf{27} & \textbf{28} -- 33 & \textbf{28} -- 36 \\
    \end{tabular}
  \end{table}
  \note{
    \begin{itemize}
    \end{itemize}
  }
\end{frame}

\begin{frame}{Our Contribution}
  \definecolor{counterexample}{rgb}{0.8, 0.1, 0.1}
  \setbeamercolor{block title alerted}{bg=gray!20,fg=black}
  \setbeamercolor{block body alerted}{bg=gray!5}
  \begin{itemize}
    \item<+-> Verified existing results and generated executable algorithms
    \item<+-> Calculated and corrected new lower bounds
    \item<+-> Introduced compatible posets and backward search as novelty for this problem
    \item<+-> Disproved a conjecture on optimal algorithm structure from Gasarch:
      ``An optimal algorithm exists that first compares all elements pairwise.''
      \begin{alertblock}<+->{Counterexample: $n=12, i=5$}
        The conjecture implies a minimum of 20 comparisons are required. \\[0.5em]
        \textbf{Our discovered algorithm succeeds with only \textcolor{counterexample}{19} comparisons.}
      \end{alertblock}
  \end{itemize}
\end{frame}

\begin{frame}{Runtime Comparison} % ready
  \begin{table}[!t]
    \label{tab:times}
    \renewcommand{\arraystretch}{1.0}
    \centering
    \resizebox{1.0\textheight}{!}{%
      \begin{tabular}{c|c|l|l|l}
        $n$ & $i$ & \textbf{Forward Search} & \textbf{Backward Search} & \textbf{Oksanen}                                         \\
        \hline
        14  & 1   & 0.0s                    & 0.0s                     & 0.0s                                                     \\
        14  & 2   & 0.0s                    & 1.5s                     & 0.0s                                                     \\
        14  & 3   & 1.4s                    & 5.9s                     & \textbf{0.6s}                                            \\
        14  & 4   & \textbf{35.9s}          & 46.9s                    & 1m 47s                                                   \\
        14  & 5   & 17m 27s                 & \textbf{15m 33s}         & 6h 29m                                                   \\
        14  & 6   & 2h 40m                  & \textbf{1h 40m}          & 4d 10h                                                   \\
        14  & 7   & 14h 40m                 & \textbf{6h 27m}          & >5d                                                      \\
        \hline
        15  & 1   & 0.0s                    & 0.0s                     & 0.0s                                                     \\
        15  & 2   & 0.1s                    & 4.0s                     & \textbf{0.0s}                                            \\
        15  & 3   & 2.8s                    & 25.9s                    & \textbf{1.4s}                                            \\
        15  & 4   & \textbf{2m 24s}         & 13m 11s                  & 27m 17s                                                  \\
        15  & 5   & 1h 12m                  & \textbf{45m 52s}         & 1d 5h 40m\footnote{calculates a non-optimal lower bound} \\
        15  & 6   & 1d 8h 37m               & \textbf{19h 30m}         & >5d                                                      \\
        15  & 7   & 4d 23h 37m              & \textbf{1d 5h 43m}       & >5d                                                      \\
        15  & 8   & 14d 1h 51m              & \textbf{3d 8h 9m}        & >5d                                                      \\
      \end{tabular}
    }
  \end{table}
\end{frame}

\begin{frame}{Future Work}
  \vspace{-1.2cm}
  \begin{columns}
    \begin{column}{.49\textwidth}
      \begin{itemize}
        \item<+-> Idea of bidirectional Search: Run forward and backward search simultaneously
        \item<+-> Challenge: The searches intersect only after $> 99.9\%$ of the search space has been explored in both searches
        \item<+-> Forward search can prune subtrees, but the backward search needs to calculate the full tree
      \end{itemize}
    \end{column}
    \begin{column}{.49\textwidth}
      \onslide<2->{
        \begin{figure}[!b]
          \centering
          \renewcommand{\arraystretch}{0.9}
          \resizebox{0.85\textheight}{!}{%
            \input{../article/figures/tikz_backward_forward_13_6.tex}
          }
          \caption{Poset distribution for $n = 13$, $i = 7$}
          \label{fig:backward_forward_count_13_6}
        \end{figure}
      }
    \end{column}
  \end{columns}
\end{frame}

% TODO: prevent in toc above
\begin{frame}[shrink=25]{References}
  \nocite{*}
  \printbibliography[heading=none]
\end{frame}

\thanksframe